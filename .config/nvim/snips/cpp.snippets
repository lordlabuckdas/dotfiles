snippet tpl "cp template" bw
#include "bits/stdc++.h"
#define SYNC std::ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)
using namespace std;

int main() {
	SYNC;
	$0
	return 0;
}
endsnippet

snippet sieve "sieve of eratosthenes"
vector<bool> prime(1e6+7, 0);

void sieve(long long n) {
	prime[0] = prime[1] = false;
	for (long long p = 2; p * p <= n; p++) {
		if (prime[p] == true) {
			for (long long i = p * p; i <= n; i += p)
				prime[i] = false;
		}
	}
}
endsnippet

snippet bs "binary search"
long long low = ${1:0}, high = ${2:n - 1}, mid;
while (low <= high) {
	mid = (low + high) / 2;
	if (${3:a}[mid] < ${4:x}) {
		low = mid + 1;
	}
	else if (${3:a}[mid] == ${4:x}) {
		$0
	}
	else {
		high = mid - 1;
	}
}
endsnippet

snippet lc "leetcode template" bw
#include "bits/stdc++.h"
using namespace std;

$2 roll($1) {
	// int n = A.size();
	// int m = A[0].size();
	$2 $4;
	$0
	return $4;
}

int main() {
	$1;
	$2 op = roll();
	// cout<<op;
	// for(auto i: op) {
	// 	cout<<i<<" ";
	// }
	// for(auto i: op) {
	// 	for(auto j: i)
	// 		cout<<j<<" ";
	// 	cout<<"\n";
	// }
	return 0;
}
endsnippet

snippet lili "linked list structure" bw
struct ListNode {
	int val;
	ListNode *next;
	ListNode(): val(0), next(NULL) {}
	ListNode(int x): val(x), next(NULL) {}
};
endsnippet

snippet funclili "linked list functions" bw
void printLL(ListNode *head) {
	ListNode *tmp = head;
	while(tmp!=NULL) {
		cout<<tmp->val<<"-->";
		tmp=tmp->next;
	}
}

ListNode* revLL(ListNode *start) {
	ListNode *curr = start, *prev = NULL, *next = NULL;
	while(curr) {
		next = curr->next;
		curr->next = prev;
		prev = curr;
		curr = next;
	}
	return prev;
}

ListNode* midLL(ListNode *head) {
	ListNode *fast = head, *slow = head;
	while(fast!=NULL && fast->next!=NULL && fast->next->next!NULL) {
		fast = fast->next->next;
		slow = slow->next;
	}
	return slow;
}

endsnippet

snippet testlili "linked list starter" bw
ListNode *head = new ListNode(1), *tmp;
ListNode *prev = head;
for(int i=2;i<7;i++) {
	tmp = new ListNode();
	tmp->val = i;
	tmp->next = NULL;
	prev->next = tmp;
	prev = tmp;
}
endsnippet

snippet comb "nCr" bw
long ncr(int n,int r)
{
	long ans=1;
	r=r>n-r?n-r:r;
	int j=1;
	for(;j<=r;j++,n--)
	{
		if(n%j==0) {
			ans*=n/j;
		} else if(ans%j==0) {
			ans=ans/j*n;
		} else {
			ans=(ans*n)/j;
		}
	}
	return ans;
}

endsnippet

snippet nodetree "treeNode" bw
struct TreeNode {
	int val;
	TreeNode *left, *right;
	TreeNode(int x): val(x), left(NULL), right(NULL) {}
};

endsnippet

snippet bst "binary search tree" bw
class bst {
	TreeNode *root;
public:
	bst() {
		root=NULL;
	}
	bool isEmpty() {
		return (root==NULL);
	}
	void insertNode(int data) {
		TreeNode *temp = new TreeNode(data);
		if(isEmpty()) {
			root = temp;
		} else {
			TreeNode *parent=NULL, *ptr=root;
			while(ptr!=NULL) {
				parent = ptr;
				if(data > ptr->val)
					ptr=ptr->right;
				else
					ptr=ptr->left;
			}
			if(data < parent->val)
				parent->left = temp;
			else
				parent->right = temp;
		}
	}
	void inOrderTraversalRec() {
		inOrderTraversalRec(root);
	}
	void preOrderTraversalRec() {
		preOrderTraversalRec(root);
	}
	void postOrderTraversalRec() {
		postOrderTraversalRec(root);
	}
	void inOrderTraversalRec(TreeNode *ptr) {
		if(ptr!=NULL) {
			inOrderTraversalRec(ptr->left);
			cout<<ptr->val<<" ";
			inOrderTraversalRec(ptr->right);
		}
	}
	void preOrderTraversalRec(TreeNode *ptr) {
		if(ptr!=NULL) {
			cout<<ptr->val<<" ";
			preOrderTraversalRec(ptr->left);
			preOrderTraversalRec(ptr->right);
		}
	}
	void postOrderTraversalRec(TreeNode *ptr) {
		if(ptr!=NULL) {
			postOrderTraversalRec(ptr->left);
			postOrderTraversalRec(ptr->right);
			cout<<ptr->val<<" ";
		}
	}
	void inOrderTraversalItr() {
		TreeNode *curr = root;
		stack<TreeNode*> s;
		while(curr!=NULL || !s.empty()) {
			if(curr!=NULL) {
				s.push(curr);
				curr = curr->left;
			} else {
				curr = s.top();
				s.pop();
				cout<<curr->val<<" ";
				curr = curr->right;
			}
		}
	}
	void preOrderTraversalItr() {
		if(isEmpty())
			return;
		TreeNode *curr = root;
		stack<TreeNode*> s;
		s.push(curr);
		while(!s.empty()) {
			curr = s.top();
			s.pop();
			cout<<curr->val<<" ";
			if(curr->right)
				s.push(curr->right);
			if(curr->left)
				s.push(curr->left);
		}
	}
	void postOrderTraversalItr() {
		stack<TreeNode*> s;
		s.push(root);
		stack<int> out;
		while (!s.empty()) {
			TreeNode* curr = s.top();
			s.pop();
			out.push(curr->val);
			if (curr->left) {
				s.push(curr->left);
			}
			if (curr->right) {
				s.push(curr->right);
			}
		}
		while (!out.empty()) {
			cout << out.top() << " ";
			out.pop();
		}
	}
};

endsnippet

snippet inorder "inorder tree traversal" bw
void inOrderTraversalRec(TreeNode *ptr) {
	if(ptr!=NULL) {
		inOrderTraversalRec(ptr->left);
		cout<<ptr->val<<" ";
		inOrderTraversalRec(ptr->right);
	}
}

endsnippet

snippet testtree "starter template for trees" bw
TreeNode *root = new TreeNode(1);
root->left = new TreeNode(2);
root->right = new TreeNode(3);
root->left->left = new TreeNode(4);
root->left->right = new TreeNode(5);
root->right->left = new TreeNode(6);
root->right->right = new TreeNode(7);
endsnippet

snippet debmac "macro for debugging" bw
#define deb(...) logger(#__VA_ARGS__, __VA_ARGS__)
template<typename ...Args>
void logger(string vars, Args&&... values) {
	cout << vars << " = ";
	string delim = "";
	(..., (cout << delim << values, delim = ", "));
}

endsnippet
